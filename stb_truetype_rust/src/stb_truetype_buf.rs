// Generated by Hebron at 1/3/2022 8:25:33 AM

use crate::*;
use c_runtime;
use std;

#[derive(Debug, Copy, Clone)]
pub struct stbtt__buf {
    pub data: *mut u8,
    pub cursor: i32,
    pub size: i32,
}

impl std::default::Default for stbtt__buf {
    fn default() -> Self {
        stbtt__buf {
            data: std::ptr::null_mut(),
            cursor: 0,
            size: 0,
        }
    }
}

pub unsafe fn stbtt__buf_get(mut b: *mut stbtt__buf, mut n: i32) -> u32 {
    let mut v: u32 = ((0) as u32);
    let mut i: i32 = 0;

    i = ((0) as i32);
    while (i < n) {
        v = ((v << 8) | ((stbtt__buf_get8(b)) as u32));
        c_runtime::postInc(&mut i);
    }
    return ((v) as u32);
}

pub unsafe fn stbtt__buf_get8(mut b: *mut stbtt__buf) -> u8 {
    if (*b).cursor >= (*b).size {
        return ((0) as u8);
    }
    return ((*(*b)
        .data
        .offset((c_runtime::postInc(&mut (*b).cursor)) as isize)) as u8);
}

pub unsafe fn stbtt__buf_peek8(mut b: *mut stbtt__buf) -> u8 {
    if (*b).cursor >= (*b).size {
        return ((0) as u8);
    }
    return ((*(*b).data.offset(((*b).cursor) as isize)) as u8);
}

pub unsafe fn stbtt__buf_range(mut b: *mut stbtt__buf, mut o: i32, mut s: i32) -> stbtt__buf {
    let mut r: stbtt__buf = stbtt__new_buf(std::ptr::null_mut(), ((0) as u64));
    if o < 0 || s < 0 || o > (*b).size || s > (*b).size - o {
        return ((r) as stbtt__buf);
    }
    r.data = ((*b).data).offset((o) as isize);
    r.size = ((s) as i32);
    return ((r) as stbtt__buf);
}

pub unsafe fn stbtt__buf_seek(mut b: *mut stbtt__buf, mut o: i32) {
    (*b).cursor = ((if (o > (*b).size || o < 0) {
        (*b).size
    } else {
        o
    }) as i32);
}

pub unsafe fn stbtt__buf_skip(mut b: *mut stbtt__buf, mut o: i32) {
    stbtt__buf_seek(b, (*b).cursor + o);
}

pub unsafe fn stbtt__cff_get_index(mut b: *mut stbtt__buf) -> stbtt__buf {
    let mut count: i32 = 0;
    let mut start: i32 = 0;
    let mut offsize: i32 = 0;
    start = (((*b).cursor) as i32);
    count = ((stbtt__buf_get((b), 2)) as i32);
    if (count) != 0 {
        offsize = ((stbtt__buf_get8(b)) as i32);
        stbtt__buf_skip(b, offsize * count);
        stbtt__buf_skip(b, ((stbtt__buf_get(b, offsize) - ((1) as u32)) as i32));
    }
    return ((stbtt__buf_range(b, start, (*b).cursor - start)) as stbtt__buf);
}

pub unsafe fn stbtt__cff_index_count(mut b: *mut stbtt__buf) -> i32 {
    stbtt__buf_seek(b, 0);
    return ((stbtt__buf_get((b), 2)) as i32);
}

pub unsafe fn stbtt__cff_int(mut b: *mut stbtt__buf) -> u32 {
    let mut b0: i32 = ((stbtt__buf_get8(b)) as i32);
    if b0 >= 32 && b0 <= 246 {
        return ((b0 - 139) as u32);
    } else {
        if b0 >= 247 && b0 <= 250 {
            return (((b0 - 247) * 256 + ((stbtt__buf_get8(b)) as i32) + 108) as u32);
        } else {
            if b0 >= 251 && b0 <= 254 {
                return ((-(b0 - 251) * 256 - ((stbtt__buf_get8(b)) as i32) - 108) as u32);
            } else {
                if b0 == 28 {
                    return ((stbtt__buf_get((b), 2)) as u32);
                } else {
                    if b0 == 29 {
                        return ((stbtt__buf_get((b), 4)) as u32);
                    }
                }
            }
        }
    }

    return ((0) as u32);
}

pub unsafe fn stbtt__cff_skip_operand(mut b: *mut stbtt__buf) {
    let mut v: i32 = 0;
    let mut b0: i32 = ((stbtt__buf_peek8(b)) as i32);

    if b0 == 30 {
        stbtt__buf_skip(b, 1);
        while ((*b).cursor < (*b).size) {
            v = ((stbtt__buf_get8(b)) as i32);
            if (v & 0xF) == 0xF || (v >> 4) == 0xF {
                break;
            }
        }
    } else {
        stbtt__cff_int(b);
    }
}

pub unsafe fn stbtt__dict_get(mut b: *mut stbtt__buf, mut key: i32) -> stbtt__buf {
    stbtt__buf_seek(b, 0);
    while ((*b).cursor < (*b).size) {
        let mut start: i32 = (*b).cursor;
        let mut end: i32 = 0;
        let mut op: i32 = 0;
        while (((stbtt__buf_peek8(b)) as i32) >= 28) {
            stbtt__cff_skip_operand(b);
        }
        end = (((*b).cursor) as i32);
        op = ((stbtt__buf_get8(b)) as i32);
        if op == 12 {
            op = (((stbtt__buf_get8(b)) as i32) | 0x100);
        }
        if op == key {
            return ((stbtt__buf_range(b, start, end - start)) as stbtt__buf);
        }
    }
    return ((stbtt__buf_range(b, 0, 0)) as stbtt__buf);
}

pub unsafe fn stbtt__dict_get_ints(
    mut b: *mut stbtt__buf,
    mut key: i32,
    mut outcount: i32,
    mut out: *mut u32,
) {
    let mut i: i32 = 0;
    let mut operands: stbtt__buf = stbtt__dict_get(b, key);
    i = ((0) as i32);
    while (i < outcount && operands.cursor < operands.size) {
        *out.offset((i) as isize) = ((stbtt__cff_int(((&mut operands) as *mut stbtt__buf))) as u32);
        c_runtime::postInc(&mut i);
    }
}

pub unsafe fn stbtt__new_buf(mut p: *mut u8, mut size: u64) -> stbtt__buf {
    let mut r: stbtt__buf = stbtt__buf::default();

    r.data = p;
    r.size = ((size) as i32);
    r.cursor = ((0) as i32);
    return ((r) as stbtt__buf);
}

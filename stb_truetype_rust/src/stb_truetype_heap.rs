// Generated by Hebron at 1/3/2022 9:57:29 AM

use crate::*;
use c_runtime;
use std;

#[derive(Debug, Copy, Clone)]
pub struct stbtt__hheap {
    pub head: *mut stbtt__hheap_chunk,
    pub first_free: *mut u8,
    pub num_remaining_in_head_chunk: i32,
}

#[derive(Debug, Copy, Clone)]
pub struct stbtt__hheap_chunk {
    pub next: *mut stbtt__hheap_chunk,
}

impl std::default::Default for stbtt__hheap {
    fn default() -> Self {
        stbtt__hheap {
            head: std::ptr::null_mut(),
            first_free: std::ptr::null_mut(),
            num_remaining_in_head_chunk: 0,
        }
    }
}

impl std::default::Default for stbtt__hheap_chunk {
    fn default() -> Self {
        stbtt__hheap_chunk {
            next: std::ptr::null_mut(),
        }
    }
}

pub unsafe fn stbtt__hheap_alloc(
    mut hh: *mut stbtt__hheap,
    mut size: u64,
    mut userdata: *const u8,
) -> *mut u8 {
    if ((*hh).first_free) != std::ptr::null_mut() {
        let mut p: *mut u8 = (*hh).first_free;
        (*hh).first_free = *((p) as *mut *mut u8);
        return p;
    } else {
        if (*hh).num_remaining_in_head_chunk == 0 {
            let mut count: i32 = (if size < ((32) as u64) {
                2000
            } else {
                if size < ((128) as u64) {
                    800
                } else {
                    100
                }
            });
            let mut c: *mut stbtt__hheap_chunk = ((c_runtime::malloc(
                std::mem::size_of::<stbtt__hheap_chunk>() as u64 + size * ((count) as u64),
            )) as *mut stbtt__hheap_chunk);
            if c == std::ptr::null_mut() {
                return std::ptr::null_mut();
            }
            (*c).next = (*hh).head;
            (*hh).head = c;
            (*hh).num_remaining_in_head_chunk = ((count) as i32);
        }
        c_runtime::preDec(&mut (*hh).num_remaining_in_head_chunk);
        return ((((*hh).head) as *mut u8)
            .offset((std::mem::size_of::<stbtt__hheap_chunk>() as u64) as isize))
        .offset((size * (((*hh).num_remaining_in_head_chunk) as u64)) as isize);
    }
}

pub unsafe fn stbtt__hheap_cleanup(mut hh: *mut stbtt__hheap, mut userdata: *const u8) {
    let mut c: *mut stbtt__hheap_chunk = (*hh).head;
    while ((c) != std::ptr::null_mut()) {
        let mut n: *mut stbtt__hheap_chunk = (*c).next;
        c_runtime::free(((c) as *mut u8));
        c = n;
    }
}

pub unsafe fn stbtt__hheap_free(mut hh: *mut stbtt__hheap, mut p: *mut u8) {
    *((p) as *mut *mut u8) = (*hh).first_free;
    (*hh).first_free = p;
}

pub unsafe fn stbtt__new_active(
    mut hh: *mut stbtt__hheap,
    mut e: *mut stbtt__edge,
    mut off_x: i32,
    mut start_point: f32,
    mut userdata: *const u8,
) -> *mut stbtt__active_edge {
    let mut z: *mut stbtt__active_edge = ((stbtt__hheap_alloc(
        hh,
        std::mem::size_of::<stbtt__active_edge>() as u64,
        userdata,
    )) as *mut stbtt__active_edge);
    let mut dxdy: f32 = ((*e).x1 - (*e).x0) / ((*e).y1 - (*e).y0);

    if z == std::ptr::null_mut() {
        return z;
    }
    (*z).fdx = ((dxdy) as f32);
    (*z).fdy = ((if dxdy != 0.0f32 {
        (1.0f32 / dxdy)
    } else {
        0.0f32
    }) as f32);
    (*z).fx = (((*e).x0 + dxdy * (start_point - (*e).y0)) as f32);
    (*z).fx -= ((off_x) as f32);
    (*z).direction = ((if ((*e).invert) != 0 { 1.0f32 } else { -1.0f32 }) as f32);
    (*z).sy = (((*e).y0) as f32);
    (*z).ey = (((*e).y1) as f32);
    (*z).next = std::ptr::null_mut();
    return z;
}

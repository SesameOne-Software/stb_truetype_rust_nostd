// Generated by Hebron at 1/3/2022 9:57:29 AM

use crate::*;
use c_runtime;
use core;

#[derive(Debug, Copy, Clone)]
pub struct stbtt__csctx {
    pub bounds: i32,
    pub started: i32,
    pub first_x: f32,
    pub first_y: f32,
    pub x: f32,
    pub y: f32,
    pub min_x: i32,
    pub max_x: i32,
    pub min_y: i32,
    pub max_y: i32,
    pub pvertices: *mut stbtt_vertex,
    pub num_vertices: i32,
}

impl core::default::Default for stbtt__csctx {
    fn default() -> Self {
        stbtt__csctx {
            bounds: 0,
            started: 0,
            first_x: 0.0f32,
            first_y: 0.0f32,
            x: 0.0f32,
            y: 0.0f32,
            min_x: 0,
            max_x: 0,
            min_y: 0,
            max_y: 0,
            pvertices: core::ptr::null_mut(),
            num_vertices: 0,
        }
    }
}

pub unsafe fn stbtt__csctx_close_shape(ctx: *mut stbtt__csctx) {
    if (*ctx).first_x != (*ctx).x || (*ctx).first_y != (*ctx).y {
        stbtt__csctx_v(
            ctx,
            (STBTT_vline) as u8,
            ((*ctx).first_x) as i32,
            ((*ctx).first_y) as i32,
            0,
            0,
            0,
            0,
        );
    }
}

pub unsafe fn stbtt__csctx_rccurve_to(
    ctx: *mut stbtt__csctx,
    dx1: f32,
    dy1: f32,
    dx2: f32,
    dy2: f32,
    dx3: f32,
    dy3: f32,
) {
    let cx1: f32 = (*ctx).x + dx1;
    let cy1: f32 = (*ctx).y + dy1;
    let cx2: f32 = cx1 + dx2;
    let cy2: f32 = cy1 + dy2;
    (*ctx).x = (cx2 + dx3) as f32;
    (*ctx).y = (cy2 + dy3) as f32;
    stbtt__csctx_v(
        ctx,
        (STBTT_vcubic) as u8,
        ((*ctx).x) as i32,
        ((*ctx).y) as i32,
        (cx1) as i32,
        (cy1) as i32,
        (cx2) as i32,
        (cy2) as i32,
    );
}

pub unsafe fn stbtt__csctx_rline_to(ctx: *mut stbtt__csctx, dx: f32, dy: f32) {
    (*ctx).x += (dx) as f32;
    (*ctx).y += (dy) as f32;
    stbtt__csctx_v(
        ctx,
        (STBTT_vline) as u8,
        ((*ctx).x) as i32,
        ((*ctx).y) as i32,
        0,
        0,
        0,
        0,
    );
}

pub unsafe fn stbtt__csctx_rmove_to(ctx: *mut stbtt__csctx, dx: f32, dy: f32) {
    stbtt__csctx_close_shape(ctx);
    let hebron_tmp0 = (*ctx).x + dx;
    (*ctx).first_x = hebron_tmp0;
    (*ctx).x = hebron_tmp0;
    let hebron_tmp1 = (*ctx).y + dy;
    (*ctx).first_y = hebron_tmp1;
    (*ctx).y = hebron_tmp1;
    stbtt__csctx_v(
        ctx,
        (STBTT_vmove) as u8,
        ((*ctx).x) as i32,
        ((*ctx).y) as i32,
        0,
        0,
        0,
        0,
    );
}

pub unsafe fn stbtt__csctx_v(
    c: *mut stbtt__csctx,
    mut _type_: u8,
    x: i32,
    y: i32,
    cx: i32,
    cy: i32,
    cx1: i32,
    cy1: i32,
) {
    if ((*c).bounds) != 0 {
        stbtt__track_vertex(c, x, y);
        if ((_type_) as i32) == STBTT_vcubic {
            stbtt__track_vertex(c, cx, cy);
            stbtt__track_vertex(c, cx1, cy1);
        }
    } else {
        stbtt_setvertex(
            (&mut *(*c).pvertices.offset(((*c).num_vertices) as isize)) as *mut stbtt_vertex,
            _type_,
            x,
            y,
            cx,
            cy,
        );
        (*(*c).pvertices.offset(((*c).num_vertices) as isize)).cx1 = (cx1) as i16;
        (*(*c).pvertices.offset(((*c).num_vertices) as isize)).cy1 = (cy1) as i16;
    }
    c_runtime::postInc(&mut (*c).num_vertices);
}

pub unsafe fn stbtt__run_charstring(
    info: *mut stbtt_fontinfo,
    glyph_index: i32,
    c: *mut stbtt__csctx,
) -> i32 {
    let mut in_header: i32 = 1;
    let mut maskbits: i32 = 0;
    let mut subr_stack_height: i32 = 0;
    let mut sp: i32 = 0;
    let mut v: i32 = 0;
    let mut i: i32 = 0;
    let mut b0: i32 = 0;
    let mut has_subrs: i32 = 0;
    let mut clear_stack: i32 = 0;
    let mut s: [f32; 48] = [0.0f32; 48];
    let mut subr_stack: [stbtt__buf; 10] = [stbtt__buf::default(); 10];
    let mut subrs: stbtt__buf = (*info).subrs;
    let mut b: stbtt__buf = stbtt__buf::default();
    let mut f: f32 = 0.0f32;
    b = (stbtt__cff_index_get((*info).charstrings, glyph_index)) as stbtt__buf;
    while b.cursor < b.size {
        i = (0) as i32;
        clear_stack = (1) as i32;
        b0 = (stbtt__buf_get8((&mut b) as *mut stbtt__buf)) as i32;
        if b0 == 0x13 || b0 == 0x14 {
            if (in_header) != 0 {
                maskbits += (sp / 2) as i32;
            }
            in_header = (0) as i32;
            stbtt__buf_skip((&mut b) as *mut stbtt__buf, (maskbits + 7) / 8);
        } else if b0 == 0x01 || b0 == 0x03 || b0 == 0x12 || b0 == 0x17 {
            maskbits += (sp / 2) as i32;
        } else if b0 == 0x15 {
            in_header = (0) as i32;
            if sp < 2 {
                return (0) as i32;
            }
            stbtt__csctx_rmove_to(c, s[(sp - 2) as usize], s[(sp - 1) as usize]);
        } else if b0 == 0x04 {
            in_header = (0) as i32;
            if sp < 1 {
                return (0) as i32;
            }
            stbtt__csctx_rmove_to(c, (0) as f32, s[(sp - 1) as usize]);
        } else if b0 == 0x16 {
            in_header = (0) as i32;
            if sp < 1 {
                return (0) as i32;
            }
            stbtt__csctx_rmove_to(c, s[(sp - 1) as usize], (0) as f32);
        } else if b0 == 0x05 {
            if sp < 2 {
                return (0) as i32;
            };
            while i + 1 < sp {
                stbtt__csctx_rline_to(c, s[(i) as usize], s[(i + 1) as usize]);
                i += (2) as i32;
            }
        } else if b0 == 0x07 || b0 == 0x06 {
            if sp < 1 {
                return 0;
            }
            let mut goto_vlineto = if b0 == 0x07 { 1 } else { 0 };
            loop {
                if goto_vlineto == 0 {
                    if i >= sp {
                        break;
                    }
                    stbtt__csctx_rline_to(c, s[i as usize], 0.0f32);
                    i += 1;
                }

                goto_vlineto = 0;
                if i >= sp {
                    break;
                }
                stbtt__csctx_rline_to(c, 0.0f32, s[i as usize]);
                i += 1;
            }
        } else if b0 == 0x1F || b0 == 0x1E {
            if sp < 4 {
                return 0;
            }
            let mut goto_hvcurveto = if b0 == 0x1F { 1 } else { 0 };
            loop {
                if goto_hvcurveto == 0 {
                    if i + 3 >= sp {
                        break;
                    }
                    stbtt__csctx_rccurve_to(
                        c,
                        0.0f32,
                        s[i as usize],
                        s[(i + 1) as usize],
                        s[(i + 2) as usize],
                        s[(i + 3) as usize],
                        if sp - i == 5 {
                            s[(i + 4) as usize]
                        } else {
                            0.0f32
                        },
                    );
                    i += 4;
                }

                goto_hvcurveto = 0;
                if i + 3 >= sp {
                    break;
                }
                stbtt__csctx_rccurve_to(
                    c,
                    s[i as usize],
                    0.0f32,
                    s[(i + 1) as usize],
                    s[(i + 2) as usize],
                    if sp - i == 5 {
                        s[(i + 4) as usize]
                    } else {
                        0.0f32
                    },
                    s[(i + 3) as usize],
                );
                i += 4;
            }
        } else if b0 == 0x08 {
            if sp < 6 {
                return (0) as i32;
            };
            while i + 5 < sp {
                stbtt__csctx_rccurve_to(
                    c,
                    s[(i) as usize],
                    s[(i + 1) as usize],
                    s[(i + 2) as usize],
                    s[(i + 3) as usize],
                    s[(i + 4) as usize],
                    s[(i + 5) as usize],
                );
                i += (6) as i32;
            }
        } else if b0 == 0x18 {
            if sp < 8 {
                return (0) as i32;
            };
            while i + 5 < sp - 2 {
                stbtt__csctx_rccurve_to(
                    c,
                    s[(i) as usize],
                    s[(i + 1) as usize],
                    s[(i + 2) as usize],
                    s[(i + 3) as usize],
                    s[(i + 4) as usize],
                    s[(i + 5) as usize],
                );
                i += (6) as i32;
            }
            if i + 1 >= sp {
                return (0) as i32;
            }
            stbtt__csctx_rline_to(c, s[(i) as usize], s[(i + 1) as usize]);
        } else if b0 == 0x19 {
            if sp < 8 {
                return (0) as i32;
            };
            while i + 1 < sp - 6 {
                stbtt__csctx_rline_to(c, s[(i) as usize], s[(i + 1) as usize]);
                i += (2) as i32;
            }
            if i + 5 >= sp {
                return (0) as i32;
            }
            stbtt__csctx_rccurve_to(
                c,
                s[(i) as usize],
                s[(i + 1) as usize],
                s[(i + 2) as usize],
                s[(i + 3) as usize],
                s[(i + 4) as usize],
                s[(i + 5) as usize],
            );
        } else if b0 == 0x1A || b0 == 0x1B {
            if sp < 4 {
                return (0) as i32;
            }
            f = (0.032) as f32;
            if (sp & 1) != 0 {
                f = (s[(i) as usize]) as f32;
                c_runtime::postInc(&mut i);
            };
            while i + 3 < sp {
                if b0 == 0x1B {
                    stbtt__csctx_rccurve_to(
                        c,
                        s[(i) as usize],
                        f,
                        s[(i + 1) as usize],
                        s[(i + 2) as usize],
                        s[(i + 3) as usize],
                        (0.032) as f32,
                    );
                } else {
                    stbtt__csctx_rccurve_to(
                        c,
                        f,
                        s[(i) as usize],
                        s[(i + 1) as usize],
                        s[(i + 2) as usize],
                        (0.032) as f32,
                        s[(i + 3) as usize],
                    );
                }
                f = (0.032) as f32;
                i += (4) as i32;
            }
        } else if b0 == 0x0A || b0 == 0x1D {
            if b0 == 0x0A && has_subrs == 0 {
                if ((*info).fdselect.size) != 0 {
                    subrs = (stbtt__cid_get_glyph_subrs(info, glyph_index)) as stbtt__buf;
                }
                has_subrs = (1) as i32;
            }

            if sp < 1 {
                return (0) as i32;
            }
            v = (s[(c_runtime::preDec(&mut sp)) as usize]) as i32;
            if subr_stack_height >= 10 {
                return (0) as i32;
            }
            subr_stack[(c_runtime::postInc(&mut subr_stack_height)) as usize] = (b) as stbtt__buf;
            b = stbtt__get_subr(
                (if b0 == 0x0A { subrs } else { (*info).gsubrs }) as stbtt__buf,
                v,
            );
            if b.size == 0 {
                return (0) as i32;
            }
            b.cursor = (0) as i32;
            clear_stack = (0) as i32;
        } else if b0 == 0x0B {
            if subr_stack_height <= 0 {
                return (0) as i32;
            }
            b = (subr_stack[(c_runtime::preDec(&mut subr_stack_height)) as usize]) as stbtt__buf;
            clear_stack = (0) as i32;
        } else if b0 == 0x0E {
            stbtt__csctx_close_shape(c);
            return (1) as i32;
        } else if b0 == 0x0C {
            let mut dx1: f32 = 0.0f32;
            let mut dx2: f32 = 0.0f32;
            let mut dx3: f32 = 0.0f32;
            let mut dx4: f32 = 0.0f32;
            let mut dx5: f32 = 0.0f32;
            let mut dx6: f32 = 0.0f32;
            let mut dy1: f32 = 0.0f32;
            let mut dy2: f32 = 0.0f32;
            let mut dy3: f32 = 0.0f32;
            let mut dy4: f32 = 0.0f32;
            let mut dy5: f32 = 0.0f32;
            let mut dy6: f32 = 0.0f32;
            let mut dx: f32 = 0.0f32;
            let mut dy: f32 = 0.0f32;
            let b1: i32 = (stbtt__buf_get8((&mut b) as *mut stbtt__buf)) as i32;
            if b1 == 0x22 {
                if sp < 7 {
                    return (0) as i32;
                }
                dx1 = (s[(0) as usize]) as f32;
                dx2 = (s[(1) as usize]) as f32;
                dy2 = (s[(2) as usize]) as f32;
                dx3 = (s[(3) as usize]) as f32;
                dx4 = (s[(4) as usize]) as f32;
                dx5 = (s[(5) as usize]) as f32;
                dx6 = (s[(6) as usize]) as f32;
                stbtt__csctx_rccurve_to(c, dx1, (0) as f32, dx2, dy2, dx3, (0) as f32);
                stbtt__csctx_rccurve_to(c, dx4, (0) as f32, dx5, -dy2, dx6, (0) as f32);
            } else if b1 == 0x23 {
                if sp < 13 {
                    return (0) as i32;
                }
                dx1 = (s[(0) as usize]) as f32;
                dy1 = (s[(1) as usize]) as f32;
                dx2 = (s[(2) as usize]) as f32;
                dy2 = (s[(3) as usize]) as f32;
                dx3 = (s[(4) as usize]) as f32;
                dy3 = (s[(5) as usize]) as f32;
                dx4 = (s[(6) as usize]) as f32;
                dy4 = (s[(7) as usize]) as f32;
                dx5 = (s[(8) as usize]) as f32;
                dy5 = (s[(9) as usize]) as f32;
                dx6 = (s[(10) as usize]) as f32;
                dy6 = (s[(11) as usize]) as f32;
                stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);
                stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);
            } else if b1 == 0x24 {
                if sp < 9 {
                    return (0) as i32;
                }
                dx1 = (s[(0) as usize]) as f32;
                dy1 = (s[(1) as usize]) as f32;
                dx2 = (s[(2) as usize]) as f32;
                dy2 = (s[(3) as usize]) as f32;
                dx3 = (s[(4) as usize]) as f32;
                dx4 = (s[(5) as usize]) as f32;
                dx5 = (s[(6) as usize]) as f32;
                dy5 = (s[(7) as usize]) as f32;
                dx6 = (s[(8) as usize]) as f32;
                stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, (0) as f32);
                stbtt__csctx_rccurve_to(c, dx4, (0) as f32, dx5, dy5, dx6, -(dy1 + dy2 + dy5));
            } else if b1 == 0x25 {
                if sp < 11 {
                    return (0) as i32;
                }
                dx1 = (s[(0) as usize]) as f32;
                dy1 = (s[(1) as usize]) as f32;
                dx2 = (s[(2) as usize]) as f32;
                dy2 = (s[(3) as usize]) as f32;
                dx3 = (s[(4) as usize]) as f32;
                dy3 = (s[(5) as usize]) as f32;
                dx4 = (s[(6) as usize]) as f32;
                dy4 = (s[(7) as usize]) as f32;
                dx5 = (s[(8) as usize]) as f32;
                dy5 = (s[(9) as usize]) as f32;
                let hebron_tmp0 = s[(10) as usize];
                dx6 = hebron_tmp0;
                dy6 = hebron_tmp0;
                dx = (dx1 + dx2 + dx3 + dx4 + dx5) as f32;
                dy = (dy1 + dy2 + dy3 + dy4 + dy5) as f32;
                if c_runtime::fabs(dx) > c_runtime::fabs(dy) {
                    dy6 = (-dy) as f32;
                } else {
                    dx6 = (-dx) as f32;
                }
                stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);
                stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);
            } else {
                return (0) as i32;
            }
        } else {
            if b0 != 255 && b0 != 28 && b0 < 32 {
                return (0) as i32;
            }
            if b0 == 255 {
                f = (((stbtt__buf_get((&mut b) as *mut stbtt__buf, 4)) as i32) as f32)
                    / ((0x10000) as f32);
            } else {
                stbtt__buf_skip((&mut b) as *mut stbtt__buf, -1);
                f = ((stbtt__cff_int((&mut b) as *mut stbtt__buf)) as i16) as f32;
            }
            if sp >= 48 {
                return (0) as i32;
            }
            s[(c_runtime::postInc(&mut sp)) as usize] = (f) as f32;
            clear_stack = (0) as i32;
        }
        if (clear_stack) != 0 {
            sp = (0) as i32;
        }
    }
    return (0) as i32;
}

pub unsafe fn stbtt__track_vertex(c: *mut stbtt__csctx, x: i32, y: i32) {
    if x > (*c).max_x || (*c).started == 0 {
        (*c).max_x = (x) as i32;
    }
    if y > (*c).max_y || (*c).started == 0 {
        (*c).max_y = (y) as i32;
    }
    if x < (*c).min_x || (*c).started == 0 {
        (*c).min_x = (x) as i32;
    }
    if y < (*c).min_y || (*c).started == 0 {
        (*c).min_y = (y) as i32;
    }
    (*c).started = (1) as i32;
}
